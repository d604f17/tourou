{"version":3,"sources":["../../src/bruteforce/_orienteering.js"],"names":["directions","orienteering","iterations","maxDistance","waypoints","strategy","Promise","then","localWaypoints","workingRoutes","possibleRoutes","i","length","route","boxes","distance","push","workingRoute","shift","console","log","hash","time","forEach","localWorkingRoute","clone","isEqual","waypoint","add","pushOrReplaceIfLowerDistance","containsWaypoint","timeEnd","sort","a","b","value","first","coordinates","map","latitude","longitude","query","mode","origin","destination","pop","join","realDistance","result","routes","legs","reduce","index","resolve"],"mappings":"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","file":"_orienteering.js","sourcesContent":["import _ from 'underscore';\r\nimport Route from './Route.js';\r\nimport RouteCollection from './RouteCollection.js';\r\nimport Directions from 'directions-api';\r\n\r\n// const directions = new Directions('AIzaSyBw9WbNkrlLt4IXxpGzAAmQrRCn_PchFog');\r\nconst directions = new Directions('AIzaSyDoHGpEGGn6nwiyWXvhOvOSOoTLnWwE4TE');\r\n\r\nconst orienteering = (iterations, maxDistance, waypoints, strategy) => {\r\n  return new Promise(resolve => {\r\n    strategy(waypoints, iterations).then(boxes => {\r\n      let localWaypoints = [];\r\n      let workingRoutes = new RouteCollection();\r\n      let possibleRoutes = new RouteCollection();\r\n\r\n      for (let i = 1; i < waypoints.length; i++) {\r\n        const route = new Route(waypoints[0], waypoints[i], boxes);\r\n\r\n        if (route.distance > 0 && route.distance <= maxDistance) {\r\n          localWaypoints.push(waypoints[i]);\r\n          workingRoutes.push(route);\r\n        }\r\n      }\r\n\r\n      while (workingRoutes.length > 0) {\r\n        const workingRoute = workingRoutes.shift();\r\n        console.log(workingRoute.hash);\r\n        console.time('while');\r\n        localWaypoints.forEach(waypoint => {\r\n          const localWorkingRoute = workingRoute.clone();\r\n\r\n          // check for index istedet for object match\r\n          if (_.isEqual(waypoint, waypoints[0])) {\r\n            localWorkingRoute.add(waypoint);\r\n\r\n            if (localWorkingRoute.distance <= maxDistance)\r\n              possibleRoutes.pushOrReplaceIfLowerDistance(localWorkingRoute);\r\n          } else if (!localWorkingRoute.containsWaypoint(waypoint)) {\r\n            localWorkingRoute.add(waypoint);\r\n\r\n            if (localWorkingRoute.distance <= maxDistance)\r\n              workingRoutes.pushOrReplaceIfLowerDistance(localWorkingRoute);\r\n          }\r\n        });\r\n        console.timeEnd('while');\r\n      }\r\n\r\n      possibleRoutes.sort((a, b) => b.value - a.value);\r\n\r\n      const route = possibleRoutes.first;\r\n\r\n      const coordinates = route.waypoints.map(waypoint => {\r\n        return `${waypoint.latitude},${waypoint.longitude}`;\r\n      });\r\n\r\n      directions.query({\r\n        mode: 'walking',\r\n        origin: coordinates.shift(),\r\n        destination: coordinates.pop(),\r\n        waypoints: coordinates.join('|'),\r\n      }).then(result => {\r\n        route.realDistance = result.routes[0].legs.reduce((a, b, index) => {\r\n          if (index === 1) {\r\n            return a.distance.value + b.distance.value;\r\n          }\r\n\r\n          return a + b.distance.value;\r\n        });\r\n\r\n        resolve(route);\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\nexport default orienteering;"]}