{"version":3,"sources":["../../src/bruteforce/orienteering.js"],"names":["directions","orienteering","iterations","maxDistance","waypoints","strategy","Promise","then","localWaypoints","workingRoutes","possibleRoutes","i","length","route","boxes","distance","push","add","workingRoute","shift","forEach","localWorkingRoute","clone","isEqual","waypoint","addOrReplaceIfLowerDistance","containsWaypoint","toArray","sort","a","b","value","coordinates","map","latitude","longitude","query","mode","origin","destination","pop","join","realDistance","result","routes","legs","reduce","index","resolve"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;AACA,IAAMA,aAAa,4BAAe,yCAAf,CAAnB;;AAEA,IAAMC,eAAe,SAAfA,YAAe,CAACC,UAAD,EAAaC,WAAb,EAA0BC,SAA1B,EAAqCC,QAArC,EAAkD;AACrE,SAAO,IAAIC,OAAJ,CAAY,mBAAW;AAC5BD,aAASD,SAAT,EAAoBF,UAApB,EAAgCK,IAAhC,CAAqC,iBAAS;AAC5C,UAAIC,iBAAiB,CAACJ,UAAU,CAAV,CAAD,CAArB;AACA,UAAIK,gBAAgB,+BAApB;AACA,UAAIC,iBAAiB,+BAArB;;AAEA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIP,UAAUQ,MAA9B,EAAsCD,GAAtC,EAA2C;AACzC,YAAME,SAAQ,oBAAUT,UAAU,CAAV,CAAV,EAAwBA,UAAUO,CAAV,CAAxB,EAAsCG,KAAtC,CAAd;;AAEA,YAAID,OAAME,QAAN,GAAiB,CAAjB,IAAsBF,OAAME,QAAN,IAAkBZ,cAAc,CAA1D,EAA6D;AAC3DK,yBAAeQ,IAAf,CAAoBZ,UAAUO,CAAV,CAApB;AACAF,wBAAcQ,GAAd,CAAkBJ,MAAlB;AACD;AACF;;AAZ2C;AAe1C,YAAMK,eAAeT,cAAcU,KAAd,EAArB;AACA;;AAEAX,uBAAeY,OAAf,CAAuB,oBAAY;AACjC,cAAMC,oBAAoBH,aAAaI,KAAb,EAA1B;;AAEA;AACA,cAAI,qBAAEC,OAAF,CAAUC,QAAV,EAAoBhB,eAAe,CAAf,CAApB,CAAJ,EAA4C;AAC1Ca,8BAAkBJ,GAAlB,CAAsBO,QAAtB;;AAEA,gBAAIH,kBAAkBN,QAAlB,IAA8BZ,WAAlC,EACEO,eAAee,2BAAf,CAA2CJ,iBAA3C;AACH,WALD,MAKO,IAAI,CAACA,kBAAkBK,gBAAlB,CAAmCF,QAAnC,CAAL,EAAmD;AACxDH,8BAAkBJ,GAAlB,CAAsBO,QAAtB;;AAEA,gBAAIH,kBAAkBN,QAAlB,IAA8BZ,WAAlC,EACEM,cAAcgB,2BAAd,CAA0CJ,iBAA1C;AACH;AACF,SAfD;AAlB0C;;AAc5C,aAAOZ,cAAcG,MAAd,GAAuB,CAA9B,EAAiC;AAAA;AAoBhC;;AAEDF,uBAAiBA,eAAeiB,OAAf,EAAjB;AACAjB,qBAAekB,IAAf,CAAoB,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUA,EAAEC,KAAF,GAAUF,EAAEE,KAAtB;AAAA,OAApB;;AAEA,UAAMlB,QAAQH,eAAe,CAAf,CAAd;;AAEA,UAAMsB,cAAcnB,MAAMT,SAAN,CAAgB6B,GAAhB,CAAoB,oBAAY;AAClD,eAAUT,SAASU,QAAnB,SAA+BV,SAASW,SAAxC;AACD,OAFmB,CAApB;;AAIAnC,iBAAWoC,KAAX,CAAiB;AACfC,cAAM,SADS;AAEfC,gBAAQN,YAAYb,KAAZ,EAFO;AAGfoB,qBAAaP,YAAYQ,GAAZ,EAHE;AAIfpC,mBAAW4B,YAAYS,IAAZ,CAAiB,GAAjB;AAJI,OAAjB,EAKGlC,IALH,CAKQ,kBAAU;AAChBM,cAAM6B,YAAN,GAAqBC,OAAOC,MAAP,CAAc,CAAd,EAAiBC,IAAjB,CAAsBC,MAAtB,CAA6B,UAACjB,CAAD,EAAIC,CAAJ,EAAOiB,KAAP,EAAiB;AACjE,cAAIA,UAAU,CAAd,EAAiB;AACf,mBAAOlB,EAAEd,QAAF,CAAWgB,KAAX,GAAmBD,EAAEf,QAAF,CAAWgB,KAArC;AACD;;AAED,iBAAOF,IAAIC,EAAEf,QAAF,CAAWgB,KAAtB;AACD,SANoB,CAArB;;AAQAiB,gBAAQnC,KAAR;AACD,OAfD;AAgBD,KA7DD;AA8DD,GA/DM,CAAP;AAgED,CAjED;;kBAmEeZ,Y","file":"orienteering.js","sourcesContent":["import _ from 'underscore';\r\nimport Route from './Route.js';\r\nimport RouteCollection from './RouteCollection.js';\r\nimport Directions from 'directions-api';\r\n\r\n// const directions = new Directions('AIzaSyBw9WbNkrlLt4IXxpGzAAmQrRCn_PchFog');\r\nconst directions = new Directions('AIzaSyDoHGpEGGn6nwiyWXvhOvOSOoTLnWwE4TE');\r\n\r\nconst orienteering = (iterations, maxDistance, waypoints, strategy) => {\r\n  return new Promise(resolve => {\r\n    strategy(waypoints, iterations).then(boxes => {\r\n      let localWaypoints = [waypoints[0]];\r\n      let workingRoutes = new RouteCollection();\r\n      let possibleRoutes = new RouteCollection();\r\n\r\n      for (let i = 1; i < waypoints.length; i++) {\r\n        const route = new Route(waypoints[0], waypoints[i], boxes);\r\n\r\n        if (route.distance > 0 && route.distance <= maxDistance / 2) {\r\n          localWaypoints.push(waypoints[i]);\r\n          workingRoutes.add(route);\r\n        }\r\n      }\r\n\r\n      while (workingRoutes.length > 0) {\r\n        const workingRoute = workingRoutes.shift();\r\n        //console.log(workingRoute.hash);\r\n\r\n        localWaypoints.forEach(waypoint => {\r\n          const localWorkingRoute = workingRoute.clone();\r\n\r\n          // check for index istedet for object match\r\n          if (_.isEqual(waypoint, localWaypoints[0])) {\r\n            localWorkingRoute.add(waypoint);\r\n\r\n            if (localWorkingRoute.distance <= maxDistance)\r\n              possibleRoutes.addOrReplaceIfLowerDistance(localWorkingRoute);\r\n          } else if (!localWorkingRoute.containsWaypoint(waypoint)) {\r\n            localWorkingRoute.add(waypoint);\r\n\r\n            if (localWorkingRoute.distance <= maxDistance)\r\n              workingRoutes.addOrReplaceIfLowerDistance(localWorkingRoute);\r\n          }\r\n        });\r\n      }\r\n\r\n      possibleRoutes = possibleRoutes.toArray();\r\n      possibleRoutes.sort((a, b) => b.value - a.value);\r\n\r\n      const route = possibleRoutes[0];\r\n\r\n      const coordinates = route.waypoints.map(waypoint => {\r\n        return `${waypoint.latitude},${waypoint.longitude}`;\r\n      });\r\n\r\n      directions.query({\r\n        mode: 'walking',\r\n        origin: coordinates.shift(),\r\n        destination: coordinates.pop(),\r\n        waypoints: coordinates.join('|'),\r\n      }).then(result => {\r\n        route.realDistance = result.routes[0].legs.reduce((a, b, index) => {\r\n          if (index === 1) {\r\n            return a.distance.value + b.distance.value;\r\n          }\r\n\r\n          return a + b.distance.value;\r\n        });\r\n\r\n        resolve(route);\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\nexport default orienteering;"]}