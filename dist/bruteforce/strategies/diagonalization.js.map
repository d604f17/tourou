{"version":3,"sources":["../../../src/bruteforce/strategies/diagonalization.js"],"names":["splitBoundedBox","box","width","Math","abs","w","e","height","n","s","diagonalization","waypoints","iterations","Promise","resolve","queries","count","boxes","generateFromWaypoints","push","shift","map","all","then","data","difference","node","distance","edge","haversineDistance","multiplier","parseFloat","toFixed"],"mappings":";;;;;;AAAA;;AACA;;;;;;;;AAEA,IAAMA,kBAAkB,SAAlBA,eAAkB,CAACC,GAAD,EAAS;AAC/B,MAAMC,QAAQC,KAAKC,GAAL,CAASH,IAAII,CAAJ,GAAQJ,IAAIK,CAArB,CAAd;AACA,MAAMC,SAASJ,KAAKC,GAAL,CAASH,IAAIO,CAAJ,GAAQP,IAAIQ,CAArB,CAAf;;AAEA,MAAIP,SAASK,MAAb,EAAqB;AACnB,WAAO,CACL,yBAAe,CAACN,IAAII,CAAL,EAAQJ,IAAIO,CAAZ,CAAf,EAA+B,CAACP,IAAII,CAAJ,GAAQH,QAAQ,CAAjB,EAAoBD,IAAIQ,CAAxB,CAA/B,CADK,EAEL,yBAAe,CAACR,IAAII,CAAJ,GAAQH,QAAQ,CAAjB,EAAoBD,IAAIO,CAAxB,CAAf,EAA2C,CAACP,IAAIK,CAAL,EAAQL,IAAIQ,CAAZ,CAA3C,CAFK,CAAP;AAID,GALD,MAKO;AACL,WAAO,CACL,yBAAe,CAACR,IAAII,CAAL,EAAQJ,IAAIO,CAAZ,CAAf,EAA+B,CAACP,IAAIK,CAAL,EAAQL,IAAIQ,CAAJ,GAAQF,SAAS,CAAzB,CAA/B,CADK,EAEL,yBAAe,CAACN,IAAII,CAAL,EAAQJ,IAAIQ,CAAJ,GAAQF,SAAS,CAAzB,CAAf,EAA4C,CAACN,IAAIK,CAAL,EAAQL,IAAIQ,CAAZ,CAA5C,CAFK,CAAP;AAID;AACF,CAfD;;AAiBA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,SAAD,EAAYC,UAAZ;AAAA,SACpB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AACvB,QAAIC,gBAAJ;AACA,QAAIC,QAAQ,CAAZ;AACA,QAAIC,QAAQ,CAAC,qBAAWC,qBAAX,CAAiCP,SAAjC,CAAD,CAAZ;;AAEA,WAAOK,QAAQJ,aAAa,CAA5B,EAA+B;AAC7BK,YAAME,IAAN,iCAAcnB,gBAAgBiB,MAAMG,KAAN,EAAhB,CAAd;AACAJ;AACD;;AAEDD,cAAUE,MAAMI,GAAN,4BAAV;;AAEAR,YAAQS,GAAR,CAAYP,OAAZ,EAAqBQ,IAArB,CAA0B,gBAAQ;AAChCT,cAAQU,KAAKH,GAAL,CAAS,gBAAQ;AACvB,YAAII,mBAAJ;AADuB,YAElBxB,GAFkB,GAEXyB,IAFW,CAElBzB,GAFkB;;;AAIvB,YAAIyB,KAAKC,QAAL,GAAgB,CAApB,EAAuB;AACrBF,uBAAaC,KAAKC,QAAL,GAAgB1B,IAAI2B,IAAJ,CAASC,iBAAtC;AACA5B,cAAI6B,UAAJ,GAAiBC,WAAWN,WAAWO,OAAX,CAAmB,CAAnB,CAAX,CAAjB;AACD,SAHD,MAGO;AACL/B,cAAI6B,UAAJ,GAAiB,CAAjB;AACD;;AAED,eAAO7B,GAAP;AACD,OAZO,CAAR;AAaD,KAdD;AAeD,GA3BD,CADoB;AAAA,CAAxB;;kBA+BeS,e","file":"diagonalization.js","sourcesContent":["import {queryBoxDistance} from './strategy';\r\nimport BoundedBox from '../BoundedBox';\r\n\r\nconst splitBoundedBox = (box) => {\r\n  const width = Math.abs(box.w - box.e);\r\n  const height = Math.abs(box.n - box.s);\r\n\r\n  if (width >= height) {\r\n    return [\r\n      new BoundedBox([box.w, box.n], [box.w + width / 2, box.s]),\r\n      new BoundedBox([box.w + width / 2, box.n], [box.e, box.s]),\r\n    ];\r\n  } else {\r\n    return [\r\n      new BoundedBox([box.w, box.n], [box.e, box.s + height / 2]),\r\n      new BoundedBox([box.w, box.s + height / 2], [box.e, box.s]),\r\n    ];\r\n  }\r\n};\r\n\r\nconst diagonalization = (waypoints, iterations) => (\r\n    new Promise((resolve) => {\r\n      let queries;\r\n      let count = 0;\r\n      let boxes = [BoundedBox.generateFromWaypoints(waypoints)];\r\n\r\n      while (count < iterations - 1) {\r\n        boxes.push(...splitBoundedBox(boxes.shift()));\r\n        count++;\r\n      }\r\n\r\n      queries = boxes.map(queryBoxDistance);\r\n\r\n      Promise.all(queries).then(data => {\r\n        resolve(data.map(node => {\r\n          let difference;\r\n          let {box} = node;\r\n\r\n          if (node.distance > 0) {\r\n            difference = node.distance / box.edge.haversineDistance;\r\n            box.multiplier = parseFloat(difference.toFixed(3));\r\n          } else {\r\n            box.multiplier = 1;\r\n          }\r\n\r\n          return box;\r\n        }));\r\n      });\r\n    })\r\n);\r\n\r\nexport default diagonalization;"]}