{"version":3,"sources":["../../src/bruteforce/Route.js"],"names":["Route","a","b","boundedBoxes","edges","setValueAndDistanceAndWaypoints","hash","getHashCode","waypoint","push","last","result","contains","waypoints","value","distance","forEach","edge","index","haversineDistance","calculateMultiplier","length","sum","edgeLatitudeRange","latitude","sort","errors","boundLatitudeRange","box","n","s","isYWithinEdgeAndBox","y","isEdgeAWithinBox","longitude","w","e","isEdgeBWithinBox","hasEdgePassed","linearEquation","multiplier","reduce","start","shift","end","pop","id","map","join"],"mappings":"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","file":"Route.js","sourcesContent":["import _ from 'underscore';\r\nimport extend from 'extend';\r\nimport Edge from './Edge';\r\n\r\nexport default class Route {\r\n  constructor(a, b, boundedBoxes) {\r\n    if (a && b) {\r\n      this.edges = [new Edge(a, b)];\r\n      this.boundedBoxes = boundedBoxes;\r\n      this.setValueAndDistanceAndWaypoints();\r\n      this.hash = this.getHashCode();\r\n    }\r\n  }\r\n\r\n  add(waypoint) {\r\n    this.edges.push(new Edge(_.last(this.edges).b, waypoint));\r\n    this.setValueAndDistanceAndWaypoints();\r\n    this.hash = this.getHashCode();\r\n  }\r\n\r\n  clone() {\r\n    return extend(true, new Route(), this);\r\n  }\r\n\r\n  containsWaypoint(waypoint) {\r\n    // console.time('contains');\r\n    var result = _.contains(this.waypoints, waypoint);\r\n    // console.timeEnd('contains');\r\n    return result;\r\n  }\r\n\r\n  setValueAndDistanceAndWaypoints() {\r\n    let value = 0;\r\n    let distance = 0;\r\n    let waypoints = [];\r\n\r\n    this.edges.forEach((edge, index) => {\r\n      value += edge.a.value;\r\n      distance += edge.haversineDistance * this.calculateMultiplier(edge);\r\n      waypoints.push(edge.a);\r\n\r\n      if (index === this.edges.length - 1) {\r\n        value += edge.b.value;\r\n        waypoints.push(edge.b);\r\n      }\r\n    });\r\n\r\n    this.value = value;\r\n    this.distance = distance;\r\n    this.waypoints = waypoints;\r\n  }\r\n\r\n  calculateMultiplier(edge) {\r\n    let sum = [];\r\n    let edgeLatitudeRange = [edge.a.latitude, edge.b.latitude];\r\n\r\n    edgeLatitudeRange.sort((a, b) => a - b);\r\n\r\n    let errors = [];\r\n\r\n    this.boundedBoxes.forEach(box => {\r\n      let boundLatitudeRange = [box.n, box.s];\r\n\r\n      boundLatitudeRange.sort((a, b) => a - b);\r\n\r\n      const isYWithinEdgeAndBox = (y) => (\r\n          edgeLatitudeRange[0] <= y &&\r\n          edgeLatitudeRange[1] >= y &&\r\n          boundLatitudeRange[0] <= y &&\r\n          boundLatitudeRange[1] >= y\r\n      );\r\n\r\n      const isEdgeAWithinBox = edge.a.longitude >= box.w &&\r\n          edge.a.longitude <= box.e &&\r\n          edge.a.latitude >= box.s &&\r\n          edge.a.latitude <= box.n;\r\n\r\n      const isEdgeBWithinBox = edge.b.longitude >= box.w &&\r\n          edge.b.longitude <= box.e &&\r\n          edge.b.latitude >= box.s &&\r\n          edge.b.latitude <= box.n;\r\n\r\n      const hasEdgePassed = isEdgeAWithinBox ||\r\n          isEdgeBWithinBox ||\r\n          isYWithinEdgeAndBox(edge.linearEquation(box.w)) ||\r\n          isYWithinEdgeAndBox(edge.linearEquation(box.e));\r\n\r\n      if (hasEdgePassed) {\r\n        sum.push(box.multiplier);\r\n      }\r\n    });\r\n\r\n    if (sum.length) {\r\n      return edge.multiplier = sum.reduce((a, b) => a + b) / sum.length;\r\n    }\r\n    else {\r\n      return edge.multiplier = 1;\r\n    }\r\n  }\r\n\r\n  getHashCode() {\r\n    const waypoints = [...this.waypoints];\r\n    const start = waypoints.shift();\r\n    const end = waypoints.pop();\r\n\r\n    let hash = `${start.id}:`;\r\n\r\n    if (waypoints.length) {\r\n      waypoints.sort((a, b) => a.id - b.id);\r\n      hash += waypoints.map(waypoint => waypoint.id).join(':') + ':';\r\n    }\r\n\r\n    return hash + `${end.id}`;\r\n  }\r\n}"]}