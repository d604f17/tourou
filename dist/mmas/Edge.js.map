{"version":3,"sources":["../../src/mmas/Edge.js"],"names":["Edge","vertexA","vertexB","boxes","_vertexA","_vertexB","_initPheromone","_pheromone","_boxes","_multiplier","calculateMultiplier","coordA","latitude","y","longitude","x","coordB","_distance","Math","round","unit","sum","edgeLatitudeRange","sort","a","b","forEach","boundLatitudeRange","box","n","s","isYWithinEdgeAndBox","isEdgeAWithinBox","w","e","isEdgeBWithinBox","hasEdgePassed","linearEquation","push","multiplier","length","reduce","vertex","pheromone","m"],"mappings":"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","file":"Edge.js","sourcesContent":["import haversine from 'haversine';\n\nclass Edge {\n  constructor(vertexA, vertexB, boxes) {\n    this._vertexA = vertexA;\n    this._vertexB = vertexB;\n    this._initPheromone = 1;\n    this._pheromone = this._initPheromone;\n    this._boxes = boxes;\n    this._multiplier = this.calculateMultiplier();\n\n    const coordA = {latitude: vertexA.y, longitude: vertexA.x};\n    const coordB = {latitude: vertexB.y, longitude: vertexB.x};\n    this._distance = Math.round(haversine(coordA, coordB, {unit: 'meter'})) * this._multiplier;\n  }\n\n  get linearEquation() {\n    const m = (this._vertexB.y - this._vertexA.y) / (this._vertexB.x - this._vertexA.x);\n\n    return (x) => {\n      return m * x - m * this._vertexA.x + this._vertexA.y;\n    };\n  }\n\n  calculateMultiplier() {\n    let sum = [], edgeLatitudeRange = [this._vertexA.y, this._vertexB.y];\n\n    edgeLatitudeRange.sort((a, b) => a - b);\n\n    this._boxes.forEach(box => {\n      let boundLatitudeRange = [box.n, box.s];\n\n      boundLatitudeRange.sort((a, b) => a - b);\n\n      const isYWithinEdgeAndBox = (y) => (\n          edgeLatitudeRange[0] <= y &&\n          edgeLatitudeRange[1] >= y &&\n          boundLatitudeRange[0] <= y &&\n          boundLatitudeRange[1] >= y\n      );\n\n      const isEdgeAWithinBox = this._vertexA.x >= box.w &&\n          this._vertexA.x <= box.e &&\n          this._vertexA.y >= box.s &&\n          this._vertexA.y <= box.n;\n\n      const isEdgeBWithinBox = this._vertexB.x >= box.w &&\n          this._vertexB.x <= box.e &&\n          this._vertexB.y >= box.s &&\n          this._vertexB.y <= box.n;\n\n      const hasEdgePassed = isEdgeAWithinBox ||\n          isEdgeBWithinBox ||\n          isYWithinEdgeAndBox(this.linearEquation(box.w)) ||\n          isYWithinEdgeAndBox(this.linearEquation(box.e));\n\n      if (hasEdgePassed) {\n        sum.push(box.multiplier);\n      }\n    });\n\n    if (sum.length) {\n      return sum.reduce((a, b) => a + b) / sum.length;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  pointA() {\n    return {'x': this._vertexA.x, 'y': this._vertexA.y};\n  }\n\n  pointB() {\n    return {'x': this._vertexB.x, 'y': this._vertexB.y};\n  }\n\n  getPheromone() {\n    return this._pheromone;\n  }\n\n  getDistance() {\n    return this._distance;\n  }\n\n  contains(vertex) {\n    if (this._vertexA.x == vertex.x) {\n      return true;\n    }\n\n    if (this._vertexB.x == vertex.x) {\n      return true;\n    }\n\n    return false;\n  }\n\n  setInitialPheromone(pheromone) {\n    this._initPheromone = pheromone;\n  }\n\n  setPheromone(pheromone) {\n    this._pheromone = pheromone;\n  }\n\n  resetPheromone() {\n    this._pheromone = this._initPheromone;\n  }\n}\n\nexport default Edge;"]}