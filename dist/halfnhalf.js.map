{"version":3,"sources":["../src/halfnhalf.js"],"names":["util","require","halfnhalf","iterations","maxDistance","waypoints","Promise","count","bestRoute","bestRouteDistance","Number","MIN_VALUE","loop","min","max","then","localMin","localMax","Math","round","route","realDistance","resolve"],"mappings":";;;;;;AAEA;;AACA;;;;AACA;;;;;;AAJA,IAAMA,OAAOC,QAAQ,MAAR,CAAb;;AAMA,IAAMC,YAAY,SAAZA,SAAY,CAACC,UAAD,EAAaC,WAAb,EAA0BC,SAA1B,EAAwC;AACxD,SAAO,IAAIC,OAAJ,CAAY,mBAAW;AAC5B,QAAIC,QAAQ,CAAZ;AACA,QAAIC,kBAAJ;AACA,QAAIC,oBAAoBC,OAAOC,SAA/B;;AAEA,KAAC,SAASC,IAAT,CAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AACvB,UAAIP,QAAQJ,UAAZ,EAAwB;AACtB,UAAEI,KAAF;AACA,oCAAa,CAAb,EAAgBO,GAAhB,EAAqBT,SAArB,mBAAqCU,IAArC,CAA0C,iBAAS;AACjD,cAAIC,WAAWH,GAAf;AAAA,cAAoBI,WAAWH,GAA/B;;AAEA,cAAII,KAAKC,KAAL,CAAWN,GAAX,MAAoBK,KAAKC,KAAL,CAAWL,GAAX,CAAxB,EAAyC;AACvCP,oBAAQJ,UAAR;AACAK,wBAAYY,KAAZ;AACAX,gCAAoBW,MAAMC,YAA1B;AACD,WAJD,MAIO,IAAID,MAAMC,YAAN,GAAqBjB,WAAzB,EAAsC;AAC3Ca,uBAAWJ,MAAM,CAACC,MAAMD,GAAP,IAAc,CAA/B;AACD,WAFM,MAEA,IAAIO,MAAMC,YAAN,GAAqBjB,WAAzB,EAAsC;AAC3C,gBAAIgB,MAAMC,YAAN,GAAqBZ,iBAAzB,EAA4C;AAC1CD,0BAAYY,KAAZ;AACAX,kCAAoBW,MAAMC,YAA1B;AACD;AACDL,uBAAWF,GAAX;AACAG,uBAAWH,MAAM,CAACA,MAAMD,GAAP,IAAc,CAA/B;AACD,WAPM,MAOA;AACLN,oBAAQJ,UAAR;AACAK,wBAAYY,KAAZ;AACAX,gCAAoBW,MAAMC,YAA1B;AACD;AACDT,eAAKI,QAAL,EAAeC,QAAf;AACD,SAtBD;AAuBD,OAzBD,MAyBO;AACLK,gBAAQd,SAAR;AACD;AACF,KA7BD,EA6BG,CA7BH,EA6BMJ,WA7BN;AA8BD,GAnCM,CAAP;AAoCD,CArCD;;kBAuCeF,S","file":"halfnhalf.js","sourcesContent":["const util = require('util');\r\n\r\nimport {one} from './strategies';\r\nimport orienteering from './orienteering';\r\nimport directions from 'directions';\r\n\r\nconst halfnhalf = (iterations, maxDistance, waypoints) => {\r\n  return new Promise(resolve => {\r\n    let count = 0;\r\n    let bestRoute;\r\n    let bestRouteDistance = Number.MIN_VALUE;\r\n\r\n    (function loop(min, max) {\r\n      if (count < iterations) {\r\n        ++count;\r\n        orienteering(0, max, waypoints, one).then(route => {\r\n          let localMin = min, localMax = max;\r\n\r\n          if (Math.round(min) === Math.round(max)) {\r\n            count = iterations;\r\n            bestRoute = route;\r\n            bestRouteDistance = route.realDistance;\r\n          } else if (route.realDistance > maxDistance) {\r\n            localMax = min + (max - min) / 2;\r\n          } else if (route.realDistance < maxDistance) {\r\n            if (route.realDistance > bestRouteDistance) {\r\n              bestRoute = route;\r\n              bestRouteDistance = route.realDistance;\r\n            }\r\n            localMin = max;\r\n            localMax = max + (max - min) / 2;\r\n          } else {\r\n            count = iterations;\r\n            bestRoute = route;\r\n            bestRouteDistance = route.realDistance;\r\n          }\r\n          loop(localMin, localMax);\r\n        });\r\n      } else {\r\n        resolve(bestRoute);\r\n      }\r\n    })(0, maxDistance);\r\n  });\r\n};\r\n\r\nexport default halfnhalf;\r\n"]}