{"version":3,"sources":["../../src/apis/geocode.js"],"names":["GeocodeAPI","key","url","address","resolve","reject","parameters","stringify","json","then","result","status","constructor","Array","_request","requests","map","a","request","delay","concurrency"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;;;IAEMA,U;AACJ,sBAAYC,GAAZ,EAAiB;AAAA;;AACf,SAAKA,GAAL,GAAWA,GAAX;AACA,SAAKC,GAAL,GAAW,mDAAX;AACD;;;;6BAEQC,O,EAAS;AAAA;;AAChB,aAAO,uBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,aAAa,aAAGC,SAAH,CAAa;AAC9BJ,0BAD8B;AAE9BF,eAAK,MAAKA;AAFoB,SAAb,CAAnB;;AAKA,sCAAG,EAACC,KAAK,MAAKA,GAAL,GAAW,GAAX,GAAiBI,UAAvB,EAAmCE,MAAM,IAAzC,EAAH,EAAmDC,IAAnD,CAAwD,kBAAU;AAChE,cAAIC,OAAOC,MAAP,KAAkB,kBAAtB,EAA0C;AACxCN,mBAAOK,OAAO,eAAP,CAAP;AACD,WAFD,MAEO;AACLN,oBAAQM,MAAR;AACD;AACF,SAND;AAOD,OAbM,CAAP;AAcD;;;0BAEKP,O,EAAS;AAAA;;AACb,UAAIA,QAAQS,WAAR,KAAwBC,KAA5B,EACE,OAAO,KAAKC,QAAL,CAAcX,OAAd,CAAP;;AAEF,aAAO,uBAAY,mBAAW;AAC5B,YAAMY,WAAWZ,QAAQa,GAAR,CAAY;AAAA,iBAAK;AAAA,mBAAM,OAAKF,QAAL,CAAcG,CAAd,CAAN;AAAA,WAAL;AAAA,SAAZ,CAAjB;;AAEA,2BAAQD,GAAR,CAAYD,QAAZ,EAAsB,UAACG,OAAD,EAAa;AACjC,iBAAO,mBAAQC,KAAR,CAAc,IAAd,EAAoBD,SAApB,CAAP;AACD,SAFD,EAEG,EAACE,aAAa,EAAd,EAFH,EAEsBX,IAFtB,CAE2B,kBAAU;AACnCL,kBAAQM,MAAR;AACD,SAJD;AAKD,OARM,CAAP;AASD;;;;;;kBAGYV,U","file":"geocode.js","sourcesContent":["import qs from 'qs';\nimport rp from 'request-promise';\nimport Promise from 'bluebird';\n\nclass GeocodeAPI {\n  constructor(key) {\n    this.key = key;\n    this.url = 'https://maps.googleapis.com/maps/api/geocode/json';\n  }\n\n  _request(address) {\n    return new Promise((resolve, reject) => {\n      const parameters = qs.stringify({\n        address,\n        key: this.key,\n      });\n\n      rp({url: this.url + '?' + parameters, json: true}).then(result => {\n        if (result.status === 'OVER_QUERY_LIMIT') {\n          reject(result['error_message']);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  query(address) {\n    if (address.constructor !== Array)\n      return this._request(address);\n\n    return new Promise(resolve => {\n      const requests = address.map(a => () => this._request(a));\n\n      Promise.map(requests, (request) => {\n        return Promise.delay(1000, request());\n      }, {concurrency: 50}).then(result => {\n        resolve(result);\n      });\n    });\n  }\n}\n\nexport default GeocodeAPI;"]}