{"version":3,"sources":["../../src/strategies/diagonalization.js"],"names":["splitBoundedBox","box","width","Math","abs","w","e","height","n","s","asyncIterate","list","callback","iterate","index","value","done","length","diagonalization","waypoints","iterations","Promise","resolve","count","boxes","generateFromWaypoints","push","shift","queries","map","origin","destination","query","then","result","forEach","i","route","directions","routes","distance","difference","haversineDistance","multiplier","parseFloat","toFixed"],"mappings":"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","file":"diagonalization.js","sourcesContent":["import {queryBoxDistance} from './strategy';\nimport BoundedBox from '../BoundedBox';\nimport directions from './../directions';\n\nconst splitBoundedBox = (box) => {\n  const width = Math.abs(box.w - box.e);\n  const height = Math.abs(box.n - box.s);\n\n  if (width >= height) {\n    return [\n      new BoundedBox([box.w, box.n], [box.w + width / 2, box.s]),\n      new BoundedBox([box.w + width / 2, box.n], [box.e, box.s]),\n    ];\n  } else {\n    return [\n      new BoundedBox([box.w, box.n], [box.e, box.s + height / 2]),\n      new BoundedBox([box.w, box.s + height / 2], [box.e, box.s]),\n    ];\n  }\n};\n\nconst asyncIterate = (list, callback) => {\n  (function iterate(index) {\n\n    callback({value: list[index], done: index == list.length - 1}, index, function() {\n      if (index + 1 < list.length) iterate(++index);\n    });\n  })(0);\n};\n\nconst diagonalization = (waypoints, iterations) => (\n    new Promise((resolve) => {\n      let count = 0;\n      let boxes = [BoundedBox.generateFromWaypoints(waypoints)];\n\n      while (count < iterations - 1) {\n        boxes.push(...splitBoundedBox(boxes.shift()));\n        count++;\n      }\n\n      const queries = boxes.map(box => {\n        return {origin: `${box.n},${box.w}`, destination: `${box.s},${box.e}`};\n      });\n\n      directions.query(queries).then(directions => {\n        const result = [];\n\n        boxes.forEach((box, i) => {\n          const route = directions[i].routes[0];\n\n          if (route) {\n            const distance = route['legs'][0]['distance']['value'];\n            const difference = distance / box.haversineDistance;\n            box.multiplier = parseFloat(difference.toFixed(3));\n          } else {\n            box.multiplier = 1;\n          }\n\n          result.push(box);\n        });\n\n        resolve(result);\n      });\n    })\n);\n\nexport default diagonalization;"]}