{"version":3,"sources":["../../src/strategies/diagonalization.js"],"names":["splitBoundedBox","box","width","Math","abs","w","e","height","n","s","asyncIterate","list","callback","iterate","index","value","done","length","diagonalization","waypoints","iterations","Promise","resolve","queries","count","boxes","generateFromWaypoints","push","shift","map","nodes","data","next","then","node","difference","distance","haversineDistance","multiplier","parseFloat","toFixed"],"mappings":"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","file":"diagonalization.js","sourcesContent":["import {queryBoxDistance} from './strategy';\r\nimport BoundedBox from '../BoundedBox';\r\n\r\nconst splitBoundedBox = (box) => {\r\n  const width = Math.abs(box.w - box.e);\r\n  const height = Math.abs(box.n - box.s);\r\n\r\n  if (width >= height) {\r\n    return [\r\n      new BoundedBox([box.w, box.n], [box.w + width / 2, box.s]),\r\n      new BoundedBox([box.w + width / 2, box.n], [box.e, box.s]),\r\n    ];\r\n  } else {\r\n    return [\r\n      new BoundedBox([box.w, box.n], [box.e, box.s + height / 2]),\r\n      new BoundedBox([box.w, box.s + height / 2], [box.e, box.s]),\r\n    ];\r\n  }\r\n};\r\n\r\nconst asyncIterate = (list, callback) => {\r\n  (function iterate(index) {\r\n\r\n    callback({value: list[index], done: index == list.length - 1}, index, function() {\r\n      if (index + 1 < list.length) iterate(++index);\r\n    });\r\n  })(0);\r\n};\r\n\r\nconst diagonalization = (waypoints, iterations) => (\r\n    new Promise((resolve) => {\r\n      let queries;\r\n      let count = 0;\r\n      let boxes = [BoundedBox.generateFromWaypoints(waypoints)];\r\n\r\n      while (count < iterations - 1) {\r\n        boxes.push(...splitBoundedBox(boxes.shift()));\r\n        count++;\r\n      }\r\n\r\n      queries = boxes.map(function(box) {\r\n        return function() {\r\n          return queryBoxDistance(box);\r\n        };\r\n      });\r\n\r\n      let nodes = [];\r\n      asyncIterate(queries, function(data, index, next) {\r\n        data.value().then(node => {\r\n          nodes.push(node);\r\n\r\n          next();\r\n\r\n          if (data.done) {\r\n            resolve(nodes.map(node => {\r\n              let difference;\r\n              let {box} = node;\r\n\r\n              if (node.distance > 0) {\r\n                difference = node.distance / box.haversineDistance;\r\n                box.multiplier = parseFloat(difference.toFixed(3));\r\n              } else {\r\n                box.multiplier = 1;\r\n              }\r\n\r\n              return box;\r\n            }));\r\n          }\r\n        });\r\n      });\r\n\r\n      // Promise.all(queries).then(data => {\r\n      //   resolve(data.map(node => {\r\n      //     let difference;\r\n      //     let {box} = node;\r\n      //\r\n      //     if (node.distance > 0) {\r\n      //       difference = node.distance / box.haversineDistance;\r\n      //       box.multiplier = parseFloat(difference.toFixed(3));\r\n      //     } else {\r\n      //       box.multiplier = 1;\r\n      //     }\r\n      //\r\n      //     return box;\r\n      //   }));\r\n      // });\r\n    })\r\n);\r\n\r\nexport default diagonalization;"]}